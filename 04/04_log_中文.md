# 第四章：机器语言

## 0.0 目的

编写并测试**乘法程序**和 **I/O 处理程序**。

## 0.1 HACK汇编语法

### 0.1.1 @value

将**常数值**或者**变量地址**加载到A寄存器中。例如：`@42`（将42加载到A寄存器）、`@R0`（将R0的地址加载到A寄存器）。

### 0.1.2 =

可以简单理解为一次赋值操作，将等号右边的值赋予给等号左边。例如：

* `D=A` : 将A寄存器中的值传送到D寄存器中。
* `D=M` : 将RAM[A]中的值（A寄存器中的地址对应的内存单元的值）传送到D寄存器中。
* `M=D` : 将D寄存器中的值存储到RAM[A]中（A寄存器中的地址对应的内存单元）。
* `D=D+A` : 将D寄存器中的值与A寄存器中的值相加，结果存储在D寄存器中。

### 0.1.3 跳转指令

* **`0;JMP`** : 无条件跳转到指定地址。
* **`D;JGT`** : 如果D寄存器中的值大于0，则跳转到指定地址。
* **`D;JEQ`** : 如果D寄存器中的值等于0，则跳转到指定地址。
* **`D;JLT`** : 如果D寄存器中的值小于0，则跳转到指定地址。

### 0.1.4 （label）

定义标签，用于标识代码中的位置。例如：`(LOOP)` ,`(end)` 等等。可以通过 `@label` 和跳转指令使得程序在执行过程中跳转到 (`label)` 在代码中所在的位置。

0.1.5 外部设备

@KBD ：检测键盘输入

@SCREEN ：


## 一、乘法程序

该程序的输入值存储在 R0 和 R1 中。程序计算 R0*R1 的值并将其存入 R2。

因为HACK汇编程序里并没有乘法的直接表示，所以我们运用简单的小学知识利用循环通过将乘法转化为加法来实现。因此我们跑 R0 次循环使得 R1 累加自己 R0 次得到结果并存储在 R2 里就行了。各行代码注释均在代码里方便理解。

## 二、I/O 处理程序

这个程序是一个无限循环，它侦测键盘的输入。当按下任意键时，程序将屏幕变黑，即将“black”写入每一个像素。当没有键按下时，屏幕应该被清屏。这个程序只有通过模拟屏幕的观察来检查执行结果。

书中提供了在屏幕的左上角画一个黑点的示例代码：

```haskell
@SCREEN //将A寄存器的值置为内存映射区的映射到屏幕第一行的16个最左边的像素的内存字
M=1     //将最左边的像素变黑
```

这个就有点复杂了，我们一步步来，首先可以看到这个程序分成两个功能：“涂黑”和“清屏（涂白）”，而且每个都是无限循环，所以我们的代码主要分成两块内容，一块负责涂黑，一块负责涂白，在每块中间我们还要根据键盘的输入进行一个相互跳转来达到自动化。

因为是在8k屏幕下，我们先设置屏幕大小为 8192：

```haskell
@8192
D=A
@size
M=D
```

在涂黑代码块里，我们先设置循环计数值 `i=0`。然后在里面新建一个开始正式涂黑的地址，先检查有无键盘输入，有就进行下一步，没有就跳转到涂白。通过前面设置的 `size` 我们得到循环次数，在每一次循环中，屏幕上的像素点前进一位并涂黑，跑完 8192 次之后回到循环开始重新跑实现无限循环。在涂白的代码块里程序和涂黑大同小异，因此不再赘述。
